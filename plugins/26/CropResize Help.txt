=================================================================================
=================================================================================
	     CropResize Help 2021-10-22
=================================================================================
=================================================================================

https://forum.videohelp.com/threads/393752-CropResize-Cropping-resizing-script

The primary purpose of the script is to apply cropping and resizing without requiring any resizing or aspect
calculations. The script automatically applies sub-pixel cropping as required to prevent aspect error.

There's no additional plugins required for cropping and resizing, however the following plugins are required for
specific functions.

To add "FrostyBorders"
FastBlur https://forum.doom9.org/showpost.php?p=1878232 and either
AddGrainC http://avisynth.nl/index.php/AddGrainC
or neo_f3kdb https://github.com/HomeOfAviSynthPlusEvolution/neo_f3kdb
(AddGrainC is the default unless GPlugin=2 is specified using the global FCropResize function)

To enable auto cropping
AutoCrop 32 bit http://avisynth.nl/index.php/AutoCrop
AutoCrop 64 bit http://avisynth.nl/index.php/AviSynth%2B_x64_plugins

Color correction and/or resizing with the AVSResize plugin (all color formats, conversions between SD, HD & UHD)
AviSynth+ is required and XP is not supported
http://avisynth.nl/index.php/Avsresize

Color correction with the HDRTools plugin (all color formats, conversions between SD, HD & UHD)
AviSynth+ is required
https://forum.doom9.org/showthread.php?t=175488
https://github.com/jpsdr/HDRTools/releases

Color correction with the HDRMatrix plugin (all YUV formats, conversions between SD & HD)
Only HDRMatrix.dll is required from the HDRFilters plugins pack (or HDRMatrix-x64.dll for 64 bit)
https://www.videoartifact.com/hdr/

To use the Position argument for displaying the current frame number and position in time over the video
GRunT http://avisynth.nl/index.php/GRunT

=================================================================================
=================================================================================

Some recommended resizers as alternatives to the default "Spline36Resize(MT)"

Resize8 script, HBD version https://forum.doom9.org/showthread.php?t=183057

ResizeX script https://github.com/realfinder/AVS-Stuff/blob/master/avs 2.6 and up/ResizeX.avsi
ResizeX dependency https://github.com/realfinder/AVS-Stuff/blob/Community/avs 2.5 and up/Zs_RF_Shared.avsi

ResampleHQ 32 bit https://forum.doom9.org/showthread.php?t=160038
ResampleHQ 64 bit https://forum.doom9.org/showthread.php?p=1722300#post1722300

=================================================================================
=================================================================================
=================================================================================

CropResize(Source, \
OutWidth=0, OutHeight=0, \
CL=0.0, CT=0.0, CR=0.0, CB=0.0, CropDAR=0.0, CSplit=1, CAlign=false, \
AutoC=false, CThresh=30, CStart=250, CSample=5, \
CPreview=0, CLine=1, \
InDAR=0.0, InSAR=0.0, OutDAR=0.0, OutSAR=0.0, AutoAspect=false, \
Mod=4, HMod=4, \
NoResize=false, ResizeWO=false, \
Borders=false, CleanBorders=false, BColor=color_black, Frosty=false, \
ColorCorrect=0, ColorMode="", Resizer="Spline36ResizeMT", RStr="", \
GMode=1, RMode=false, PicDim=0, Position=false, Info=false)

=================================================================================
	     Basic Usage
=================================================================================

Whenever the help file refers to a source being anamorphic, it's assumed either an input display aspect ratio
(InDAR) or a sample/pixel aspect ratio (InSAR) has been specified. If neither are specified the source is assumed
to be non-anamorphic (unless CropResize is using aspect information added to a script by MeGUI).

When the help file refers to full resizing mode, it's assumed both NoResize and ResizeWO are false.
If an output aspect ratio is not specified, when the script is resizing it always resizes to "square pixel" dimensions.

Possibly the most common use for the script would be to specify a width and let the script take care of the
cropping, resizing and height. To resize a 16:9 DVD to a width of 832 while forcing the script to crop at least 10
pixels from both left and right, and 4 pixels from both top and bottom:
CropResize(832,0, 10,4,-10,-4, InDAR=16.0/9.0)

It's simple to crop and resize to your preferred resolution. For example, to force the script to crop and apply the
same cropping as above, while resizing to 16:9 dimensions (1024x576), all that's required is the following:
CropResize(1024,576, 10,4,-10,-4, InDAR=16.0/9.0)
If additional cropping is required to prevent aspect error it'll be applied automatically by the script.

Exactly the same cropping would be applied again for the following example, only the output would be 
anamorphic 16:9 with an NTSC DVD resolution.
CropResize(720,480, 10,4,-10,-4, InDAR=16.0/9.0, OutDAR=16.0/9.0)

The script has quite a few options, but once you get the hang of it, it's very easy to use, and there's no need to
calculate aspect error when resizing. The script automatically applies (sub-pixel) cropping as required to prevent
picture distortion.

---------------------------------------------------------------------------------
	     Option Precedence
---------------------------------------------------------------------------------

Some options are contradictory, or specifying them doesn't make sense under certain circumstances. In such
cases the script will usually output an error message. For example, OutDAR and OutSAR are both options for
specifying an output aspect ratio, but they're mutually exclusive so they can't be used at the same time.

---------------------------------------------------------------------------------
	     Global Options
---------------------------------------------------------------------------------

Each of the CropResize options can be enabled globally for when there's more than one instance of CropResize
in a script. See the "Global Options" section towards the end of the help file.

---------------------------------------------------------------------------------
	     Wrapper Functions
---------------------------------------------------------------------------------

Wrapper functions are included for enabling the default cropping preview and setting Info=true, reducing the
need to manually type the argument names. See the Wrapper Functions section towards the end of the help file.
Additional wrapper functions are also included for specifying options when resizing with an alternative resizer.
Most of the relevant information regarding the wrapper functions for resizers can be found at the top of the
"CropResize Resizer Functions" script.

=================================================================================
=================================================================================
	     The Options
=================================================================================
=================================================================================

=================================================================================
	     OutWidth & OutHeight
=================================================================================

OutWidth & OutHeight are explained in detail as the effect of specifying them changes according to other
options.

OutWidth (default, 0)
The output width of the video. An OutWidth of zero is considered an unspecified output width.
OutHeight (default, 0)
The output height of the video. An OutHeight of zero is considered an unspecified output height.

In full resizing mode, and when Borders=false:
If OutWidth > 0 and OutHeight = 0, the height is automatically resized according to the specified width.
If OutWidth = 0 and OutHeight > 0, the width is automatically resized according to the specified height.
If OutWidth > 0 and OutHeight > 0, they specify the output width and height.

In each of the above examples, the script will automatically crop as required to prevent aspect error when
resizing.
When OutWidth & OutHeight are both greater than zero, the script can crop a great deal of picture when the
output aspect ratio and the source aspect ratio differ by a large amount (assuming an OutDAR has not been
specified). For example, 640x480 will give you an output of 4:3 (unless an output aspect ratio is specified), so
for a 16:9 source, the script would crop a fair amount of picture from each side to prevent aspect error. In other
words, the script would crop the source to 4:3 before resizing to 640x480.

In full resizing mode, and when Borders=true, OutWidth and OutHeight still specify the output dimensions, but
instead of cropping the picture as required for the specified output resolution, the script adds borders instead.
If the specified output aspect ratio is wider than the cropped source display aspect ratio, borders will be added
to the sides.
If the specified output aspect ratio is narrower than the cropped source display aspect ratio, borders will be
added to the top and bottom.

When NoResize=true, both OutWidth and OutHeight are disabled for resizing and can only be used to add borders
if Borders=true, when they exceed the cropped picture width or height.

When ResizeWO=true, OutWidth can be used to add borders if Borders=true in the same way it does when resizing
is disabled completely. It can also be used to resize the width when an OutDAR is specified. OutHeight can be
used to add borders when ResizeWO=true, except when an OutDAR is specified. When an OutDAR is specified,
OutHeight has no effect.

Finally, OutWidth and OutHeight are disabled completely when CleanBorders=true, and can't be used to resize or
add borders. CleanBorders has a specific purpose and adds it's own borders.

---------------------------------------------------------------------------------
Additional OutWidth & OutHeight options since version 2021-02-01
---------------------------------------------------------------------------------

The new negative Outwidth and OutHeight options can only be guaranteed to work as intended in the absence
of CropResize arguments that would normally limit the cropping choice, such as a CropDAR, or when only an
OutWidth or OutHeight is specified. A negative Outwidth or OutHeight can only be used in full resizing mode.

The new options (for advanced users):

When OutWidth=0 and OutHeight=0, and therefore CropResize is choosing the width and height
(mostly used that way when resizing anamorphic sources), it's possible for CropResize to crop a little
extra from the width (or height) to prevent aspect error, in addition to any "mod cropping", resulting
in the width (or height) being cropped a little further, then resized back to the previous dimensions.
As an example, the width may be cropped to 704, but to prevent aspect error CropResize may crop an
additional small amount before resizing it back to 704 again. This is because, left to it's own devices,
CropResize will crop the least amount of picture necessary to prevent aspect error. See the examples
at the end of this section.

OutWidth=-1 prevents the width being resized by ensuring the output height is always reduced and the source
height cropped to prevent aspect error, if necessary. The output width will be the (cropped) source width, but
only if the source is cropped to a mod width (Mod=4 by default). For cropping resulting in a non-mod width,
OutWidth=-1 can't prevent width resizing.

OutHeight=-1 prevents the height being resized by ensuring the output width is always reduced and the source
width cropped to prevent aspect error, if necessary. The output height will be the (cropped) source height, but
only if the source is cropped to a mod height (HMod=4 by default). For cropping resulting in a non-mod height,
OutHeight=-1 can't prevent height resizing.

As OutWidth=-1 and OutHeight=-1 have obviously conflicting goals, they cannot be used together.

OutWidth=-1 is also useful for resizing anamorphic sources in the opposite way to the default resizing.
For an NTSC 4:3 DVD, where the width would normally be reduced for square pixel dimensions, instead of
reducing the width, OutWidth=-1 forces CropResize to increase the height instead.
For any other type of DVD, where the width is normally increased for square pixel dimensions, OutWidth=-1
causes the height to be reduced instead.

In line with the new options above, an OutWidth or OutHeight can now have any negative value, for example,
OutWidth=-720 would be the same as OutWidth=720, except...

If a negative OutWidth matches the width after it's cropped, CropResize behaves as though OutWidth=-1
and prevents the width being cropped and resized further (assuming OutHeight=0).
If the negative OutWidth doesn't match the width after it's cropped, the width is simply resized normally.
A negative OutHeight serves the same purpose in relation to the height.

As a negative OutWidth and OutHeight have obviously conflicting goals, they cannot be used together.

Some examples, with the output dimensions and total cropping for each shown on the right.

A 4:3 NTSC DVD, initally cropped to 700x476    Resulting output dimensions & extra cropping

CropResize(0, 0, InSAR=8.0/9.0)            624x476  (0.00, 0.68, 0.00, -0.68)
CropResize(0, 476, InSAR=8.0/9.0)          624x476  (0.00, 0.68, 0.00, -0.68)
CropResize(0, -476, InSAR=8.0/9.0)         620x476  (1.25, 0.00, -1.25, 0.00)
CropResize(0, -1, InSAR=8.0/9.0)           620x476  (1.25, 0.00, -1.25, 0.00)
CropResize(-1, 0, InSAR=8.0/9.0)           700x532  (0.00, 1.56, 0.00, -1.56)
CropResize(-700, 0, InSAR=8.0/9.0)         700x532  (0.00, 1.56, 0.00, -1.56)
CropResize(700, 0, InSAR=8.0/9.0)          700x536  (0.33, 0.00, -0.33, 0.00)

=================================================================================
	     CL, CT, CR, & CB (defaults, 0)
=================================================================================

Cropping Left, Cropping Top, Cropping Right, Cropping Bottom.

Specify cropping (in addition to auto-cropping when AutoC=true).
Cropping can be float from CropResize version 2021-10-15.

When resizing is disabled and non-integer or non-mod cropping is specified, for example
CropResize(0,0, 1.5,0,-0.5,0, NoResize=true)
the function will increase the cropping for the appropriate mod width or height if necessary (mod4 by default)
CropResize(0,0, 2.5,0,-1.5,0, NoResize=true)
and use a resizer for cropping instead of the Crop() function, but the source won't be resized.

CR, and CB can be specified as a negative or positive integer and work the same way as for AviSynth's Crop
function. Positive numbers for CR/CB specify the width/height of the picture after any left/top cropping is applied.
Negative numbers specify the amount of right/bottom cropping.
If CR and CB are positive, they're displayed as their negative equivalents when Info=true. For example, when
cropping a 720x480 source, CropResize(0,0, 8,4,704,472) would display as Crop(8,4,-8,-4).

=================================================================================
	     CropDAR (default, not specified)
=================================================================================

Cropping Display Aspect Ratio.
CropDAR must be float (ie 1.7778 or 16.0/9.0 etc).

For CropDAR to work correctly for anamorphic sources, an appropriate source aspect ratio (InDAR or InSAR) must
be specified, otherwise it's assumed the source has "square pixels". The cropping aspect ratio is based on both
the input and output "display" aspect ratio, rather than the input/output resolution, so it's adjusted accordingly
when the input and/or output are anamorphic.

In full resizing mode, when both OutWidth & OutHeight are specified, the script crops the picture according to
the OutWidth & OutHeight before resizing (unless borders are enabled). Therefore OutWidth & OutHeight would
perform the same function as CropDAR, so when OutWidth & OutHeight are both greater than zero in full resizing
mode, CropDAR has no effect unless borders are enabled or an OutDAR is also specified (see the "CropDAR" &
"OutDAR" sections for more information on how they work together).

CropDAR can't always crop exactly to the specified aspect ratio. It depends on the mod option and resizing etc.
In such cases the cropping will be adjusted a little if necessary to prevent aspect error.

The following example illustrates how to use CropDAR to ensure the picture itself has a 4:3 display aspect ratio,
before the script adds borders to the sides for a 16:9 frame.

CropResize(1280,720, CropDAR=4.0/3.0, Borders=true)

=================================================================================
	     CSplit (default, 1)
=================================================================================

Cropping Split.  Possible values are 1, 2 or 3.

CSplit determines how the cropping is split between AviSynth's Crop function and the resizer cropping. It doesn't
apply when resizing is disabled.
When CSplit=1, AviSynth's Crop() function is used for as much mod cropping as possible (ie mod2 cropping for a
YV12 source) including any additional cropping applied by the script to prevent aspect error, and the resizer is
only used for non-mod or sub-pixel cropping.
When CSplit=2, the Crop() function is only used for any specified cropping. Additional cropping applied by the
script to prevent aspect error is applied by the resizer.
When CSplit=3, the resizer applies all cropping.

As an example, if the equivalent of Crop(4,0,-4,0) was specified and the script needed to crop an additional 11
pixels from the width to prevent aspect error, the cropping would be split in the following ways (mod2 cropping).

CropResize(704,396, 4,0,-4,0, CSplit=?)

CSplit=1 would result in: Crop(8,0,-8,0).Spline36Resize(704,396, 1.5,0,-1.5,0)
CSplit=2 would result in: Crop(4,0,-4,0).Spline36Resize(704,396, 5.5,0,-5.5,0)
CSplit=3 would result in: Crop(0,0,0,0).Spline36Resize(704,396, 9.5,0,-9.5, 0)

=================================================================================
	     CAlign (default, false)
=================================================================================

CAlign=true sets Align=true for Avisyth's Crop() function. As for Crop(), the default is false.
This only applies to AviSynth 2.6 and earlier. It does nothing for AviSynth+.

=================================================================================
	     AutoC (default, false)
=================================================================================

AutoC=true enables the auto-cropping of black borders with autocrop.dll.

Global auto-cropping can be enabled by adding the following to a script (see the "Global Options" description
for additional details).

GCropResize(AutoC=true) 

As it's usually preferable for AutoCrop to check the entire video in order to decide how much to crop, when
there's more than one instance of CropResize in a script it can be done the following way.

GCropResize(AutoC=true, InDAR=16.0/9.0)			GCropResize outputs the auto-cropped clip
Trim(0,1999).CropResize(640,480, 8,2,-8,-4)\			The auto-cropped clip is the source
++Trim(2000,2999).CropResize(640,480, 12,2,-16,-4)\	The auto-cropped clip is the source

Even though in the above example, both CropResize instances see the auto-cropped clip as the source, the
resizing and cropping calculations are still based on the original, uncropped source dimensions and aspect ratio.

Auto-cropping cannot be enabled for the CropResize function when global auto-cropping is enabled.

=================================================================================
	     CThresh (default, 30)
=================================================================================

How enthusiastically AutoCrop crops. Range 1-255.

=================================================================================
	     CStart (default, 250)
=================================================================================

CStart specifies the first frame checked for auto cropping.

=================================================================================
	     CSample (default, 5)
=================================================================================

CSample determines the number of frames checked by AutoCrop.

=================================================================================
	     CPreview (default, 0)
=================================================================================

Cropping Preview. Possible values are 0 to 4.

1, 2 & 3 show previews for any specified cropping along with any additional cropping applied by the script.

CPreview=0 (the default) disables the cropping preview.

CPreview=1. The script draws yellow lines over the image to show any specified cropping, and light blue lines
for any additional script cropping. The lines displayed over the image are included in the area to be cropped.

CPreview=2. Transparent yellow borders are overlaid on the entire area to be cropped. Transparent light blue
borders are overlaid for any additional script cropping.

CPreview=3. The specified cropping is shown as a negative version of the picture (the same as AvsPmod's
cropping preview) with any additional script cropping having a reddish color.

CPreview=4. AutoCrop's cropping preview is displayed. The lines displayed over the image by AutoCrop's
preview are not included in the area to be cropped.
When CPreview=4 for the global GCropResize function (see the "Global Options" section), GCropResize outputs
a "global" preview of the auto-cropped clip, therefore the CPreview function is disabled for any following instances
of CropResize as they can only display the auto-cropping preview.

When "p" is appended to the beginning of the function name. ie pCropResize(), a wrapper function is used to
enable the default cropping preview globally (see "changing the default preview" below), so for the following
example, each instance of CropResize would display the default cropping preview.

Trim(0,99).pCropResize(640,480, 8, 2,-10,-4)\
++Trim(100,199).CropResize(640,480, 16,6,-10,-4)\
++Trim(200,299).CropResize(640,480, 8,2,-10,-4)

As the cropping preview normally displays with the original source resolution, in a situation such as the example
above, if a cropping preview isn't enabled for all instances of CropResize it would result in an error due to the
appended videos having different resolutions. To solve this problem, there's a common resizing mode (see the
RMode section).

Changing the default cropping preview:
The default cropping preview can be CPreview 1, 2 or 3. Should you prefer the default to be something other
than CPreview=1, open the script with Notepad and find the 17th line from the bottom. It looks like this:

function CR_CPreview() { return 1 }

Change "1" to either 2 or 3 according to your preferred default for CPreview, then re-save the script.

=================================================================================
	     CLine (default, 1)
=================================================================================

CLine adjusts the thickness of the lines drawn to preview the cropping when CPreview=1.
The default thickness is one pixel. CLine can be any integer greater than zero.
If you prefer thicker cropping preview lines as the default, open the script with Notepad and find the 19th
line from the bottom. It looks like this:

function CR_CLine() { return 1 }

Change the "1" to your desired thickness in pixels, then resave the script. 

=================================================================================
	     InDAR (default, the source storage aspect ratio)
=================================================================================

Input (Source) Display Aspect Ratio.
InDAR must be float (ie 1.7778 or 16.0/9.0 etc).

A correct InDAR or InSAR is required in order to resize anamorphic sources correctly, and also for the CropDAR
option to crop correctly. If neither InDAR or InSAR are specified, the source is assumed to have "square pixels",
and the source width/height is also the display aspect ratio (unless CropResize is using MeGUI's global display
aspect ratio variables - see the MeGUI support section).

Recommended DVD display aspect ratios for both PAL and NTSC, based on the generic and mpeg4 pixel aspect
ratios specified here. https://forum.doom9.org/showthread.php?p=1058927#post1058927

For 4:3 DVDs, InDAR=15.0/11 or InDAR=1.3637 is more likely to be correct. especially if there's a substantial
amount of black down each side. Otherwise you'd use InDAR=4.0/3.0 or InDAR=1.3333.

For 16:9 DVDs, InDAR=16.0/9.0 or InDAR=1.7778 is more likely to be correct unless there's a substantial amount
of black on the sides, in which case InDAR=20.0/11.0 or InDAR=1.8182 is more likely to be correct.

There's no hard and fast rule. Whatever you think looks right. The difference isn't huge.
An alternative to specifying an input display aspect ratio is to specify an input sample (pixel) aspect ratio (see
the InSAR section).

InDAR and InSAR can't be specified at the same time.

=================================================================================
	     InSAR (default, not specified)
=================================================================================

Input Sample Aspect Ratio (pixel aspect ratio).
InSAR must be float (ie 1.4222 or 64.0/45.0 etc).

A correct InDAR or InSAR is required in order to resize anamorphic sources correctly, and also for the CropDAR
option to crop correctly. If neither InDAR or InSAR are specified the source is assumed to have "square pixels",
and the source width/height is also it's display aspect ratio (unless CropResize is using MeGUI's global display
aspect ratio variables - see the MeGUI support section).

For the appropriate DVD pixel aspect ratios for PAL and NTSC, see the link in the InDAR section above.

InDAR and InSAR can't be specified at the same time.

=================================================================================
	     OutDAR (default, not specified)
=================================================================================

Output Display Aspect Ratio.
OutDAR must be float (ie 1.7778 or 16.0/9.0 etc). It can't be used when NoResize=true.

When an OutDAR is specified, the script crops the picture according to the OutDAR, then simply resizes to the
specified width and height (or the default width and height if they're not specified). If OutDAR matches the output
dimensions, the output won't be anamorphic and the output sample aspect ratio will be 1:1. The appropriate
sample aspect ratio to use for encoding can be obtained with Info=true, or by enabling one of the script's cropping
previews.
The script won't distort the picture, so if you specify an output display aspect ratio, the source will be cropped
accordingly (unless borders are enabled). ie if OutDAR=4.0/3.0 is specified for a 16:9 source, it would be cropped
to 4:3 regardless of the output dimensions (unless borders are enabled).

As an example, the following would resize a PAL 16:9 source to NTSC 16:9 DVD dimensions.

CropResize(720,480, InDAR=16.0/9.0, OutDAR=16.0/9.0)

CropDAR - is also a "display" cropping aspect ratio, but unlike OutDAR, CropDAR doesn't adjust the output sample
(pixel) aspect ratio. OutDAR and CropDAR are normally conflicting options as they both specify a display aspect
ratio, however they can be used together when the script is adding borders. Therefore, if OutDAR and CropDAR
are specified together, borders are enabled automatically and added as required.

The following example crops and resizes a non-anamorphic source to anamorphic 4:3 NTSC dimensions, while
cropping a minimum of 12 pixels from each side, 2 pixels from the top, and 6 from the bottom. The entire output
is 15:11, with borders added to the sides to make up the difference between the CropDAR and OutDAR.

CropResize(720,480, 12,2,-12,-6, CropDAR=4.0/3.0, OutDAR=15.0/11.0)	

For the above example:
- The specified 720x480 resolution and the 15:11 output display aspect ratio result in an output sample (pixel)
aspect ratio of 10:11.
- In addition to the cropping specified, CropDAR=4.0/3.0 crops as required for the remaining picture to have a
4:3 display aspect ratio.
- The 4:3 cropped picture would be resized to 704x480, based on the calculated sample aspect ratio.
480 x (4/3) / (10/11) = 704
- Finally, to output the specified width of 720, 8 pixel borders would be added to each side.

When using more than one instance of CropResize in a script, it's possible to specify a different OutDAR or OutSAR
for each, but it generally makes no sense as there can be only one OutDAR/OutSAR per script. If it's necessary to
change the way CropResize calculates cropping and resizing based on aspect ratio, change the InDAR or InSAR
instead.

OutDAR and OutSAR can't be specified at the same time.

=================================================================================
	     OutSAR (default, not specified)
=================================================================================

Output Sample Aspect Ratio (pixel aspect ratio).
OutSAR must be specified as float (ie 64.0/45.0 or 1.4222 etc). It can't be used when NoResize=true.

When using more than one instance of CropResize in a script, it's possible to specify a different OutSAR or OutDAR
for each, but it generally makes no sense as there can be only one OutSAR/OutDAR per script. If it's necessary to
change the way CropResize calculates cropping and resizing based on aspect ratio, change the InDAR or InSAR
instead.

When OutSAR is something other than 1.0 the output is anamorphic. The script still operates in the usual manner,
only the cropping and resizing is based on the specified output sample aspect ratio, rather than the default of
resizing to "square pixel" dimensions. Borders can still be added and a cropping display aspect ratio (CropDAR) can
be specified.

A notable difference between specifying an OutSAR and an OutDAR, is when an OutDAR and CropDAR are specified
together, borders are automatically enabled. The same is not true when OutSAR and CropDAR are specified
together.

The following two examples would crop and resize the same way, in both cases cropping to 16:9 and adding eight
pixel borders to each side. The output has NTSC DVD dimensions with an mpeg4 aspect ratio (20:11 rather than
16:9).

CropResize(720,480, 12,2,-12,-6, CropDAR=16.0/9.0, InDAR=20.0/11.0, OutDAR=20.0/11.0)
CropResize(720,480, 12,2,-12,-6, CropDAR=16.0/9.0, InDAR=20.0/11.0, OutSAR=40.0/33.0, Borders=true)

OutSAR and OutDAR can't be specified at the same time.

=================================================================================
	     AutoAspect (default, false)
=================================================================================

Auto Aspect Ratio. This refers to the aspect ratio of the picture excluding any borders. It could also be thought
of as an automatic CropDAR. AutoAspect has no effect when an OutDAR is specified.

The AutoAspect option only applies in full resizing mode, and only when the script is deciding on the aspect ratio
of the picture. AutoAspect is disabled by default, but that's easy to change (see below).

What AutoAspect=true does:
When borders are disabled, if the display aspect ratio of the source after cropping is between 1.739 and 1.829,
the script will try to adjust the cropping/resizing to output exactly 16:9, or if the aspect ratio of the cropped
source is between 1.27 and 1.35, the script will try to adjust the cropping/resizing to output exactly 4:3.

When borders are enabled, AutoAspect only decreases the aspect ratio to achieve 16:9 (increasing the height),
and only increases the aspect ratio to achieve 4:3 (increasing the width).

If either a CropDAR or OutDAR are specified, the AutoAspect option has no effect, and the auto aspect ratio is
only applied if the specified Mod allows for exactly 16:9 or 4:3 (the default being Mod4).

When AutoAspect is enabled, if another argument incompatible with AutoAspect is used, such as CropDAR,
or if both an OutWidth and OutHeight are specified without borders being enabled, Info=true will show
"Not Applicable" for AutoAspect. When AutoAspect could be applied, but the cropped display aspect ratio is
outside the range outlined above, Info=true will display "Out Of Range".
When AutoAspect is enabled and within range, Info=true will tell you the display aspect ratio before the
AutoAspect adjustment.

To enable AutoAspect by default, so there's no need to enable it by typing AutoAspect=true, open the script
with Notepad and find the 20th line from the bottom. It looks like the line below. Change false to true and resave
the script.

function CR_AutoAspect() { return false }

=================================================================================
	     Mod (default, 4)
=================================================================================

Possible Mod values are 1, 2, 4, 8 and 16.

Mod sets the modulus for both the width and height (unless a value is specified for HMod).
For sources requiring the width or height to be a minimum of mod2, the script will produce an error if Mod=1 is
specified. Similarly, it'll produce an error if Mod is less than 4 for YV411.

The Mod option is disabled when CleanBorders=true, and doesn't override any specified OutWidth or OutHeight,
so it only has an effect under limited circumstances. If you specify a width or height and want them to be
mod16 (for example) you must ensure they're mod16 yourself. The Mod option only effects the width or height
when resizing is disabled, when OutWidth or OutHeight are unspecified or zero, or when the script is operating in
a mode where OutWidth or OutHeight are adding borders.

For the following example, the width would be resized to 1280, and the height automatically resized (and cropped
if necessary) for mod8.

CropResize(1280, Mod=8)

For the following example, the specified height of 720 determines the height mod, the CropDAR option crops the
picture to as close to 4:3 as the mod setting allows (in this case it would be exactly 4:3) and then it's resized to
960x720. Finally orders are added to the sides for an output width of 1280.

CropResize(1280,720, CropDAR=4.0/3.0, Mod=16, Borders=true)

When NoResize=true, the picture width and height are always cropped according to the Mod option (or HMod),
increasing any specified cropping if required.

=================================================================================
	     HMod (default, same as Mod)
=================================================================================

Possible HMod values are 1, 2, 4, 8 and 16.

Allows the height mod to be set independently of the width mod. If HMod isn't specified, the Mod option applies
to both the width and height. As with the Mod option, HMod doesn't override any specified OutHeight.

=================================================================================
	     NoResize (default, false)
=================================================================================

NoResize=true disables resizing.

NoResize=true prevents the script from resizing, so sources can only be cropped.

When NoResize=true, OutWidth and OutHeight are disabled for resizing, but they can add borders when they
exceed the source width or height after cropping if Borders=true. CropDAR can be used to crop the picture to a
particular aspect ratio.

It's not possible to specify an OutDAR or OutSAR when NoResize=true.

=================================================================================
	     ResizeWO (default, false)
=================================================================================

Resize Width Only.

ResizeWO=true prevents the script from resizing the height (it can only be cropped), as due to the way the
script's full resizing mode works (cropping extra picture from the either the width or height to prevent aspect
error) there's no way to ensure the height won't be resized, even by a small amount, and even when the
specified output height is the same as the source height after cropping. ResizeWO=true prevents height resizing.

By default the width is resized to square pixel dimensions when ResizeWO=true (for anamorphic sources), and
OutWidth and OutHeight are disabled (ignored), but as for NoResize mode, they can be used to add borders when
Borders=true. In addition to the normal cropping options, CropDAR can be used to crop the picture to a specific
resolution or aspect ratio.

Despite anamorphic output support, the primary intention of ResizeWO mode is to allow CropResize to resize an
anamorphic source to "square pixel" dimensions while preventing it from resizing the height. The following is an
example.

The source is a 16:9 PAL DVD with 720x576 dimensions. The specified cropping of 2 pixels top and bottom is
applied, 8 pixels are cropped from each side, the script crops just under half a pixel more each side to prevent
aspect error, and the cropped video is resized to a width of 1000. The height is simply the cropped height of 572,
resulting in output dimensions of 1000x572.

CropResize(0,0, 8,2,-8,-2, InDAR=16.0/9.0, ResizeWO=true)

Without any specified cropping, the following would resize the same PAL 16:9 source to 1024x576.

CropResize(InDAR=16.0/9.0, ResizeWO=true)


ResizeWO=true supports an anamorphic output, but as the height cannot be resized, it's more restricted than
full resizing mode, and a little more complicated.

As the height can't be resized, if a CropDAR and OutDAR are specified together, the OutDAR must be equal to or
greater than (wider than) the CropDAR.

To add borders in ResizeWO mode, it's usually better to specify an output sample aspect ratio rather than an
output display aspect ratio. When an OutSAR is specified and borders are enabled, it works exactly as it would
if the script was resizing an anamorphic source to square pixel dimensions. The only difference is, the picture
width changes according to the output sample aspect ratio, but when the specified OutWidth exceeds the
picture width and Borders=true, borders are added to the sides to output the desired with. If the specified
OutWidth is less than the picture width, it has no effect.
Likewise, OutHeight has no effect when Borders=true until it exceeds the picture height after cropping, in which
case it adds borders.

As the height can't be resized, OutHeight must be zero or unspecified when an output display aspect is
specified. To prevent ambiguity, the script will output an error message when an OutDAR and OutHeight are
specified together.
In contrast, an OutWidth and OutDAR can be specified together. The script simply crops the picture to the
specified OutDAR and resizes the width, unless....
Borders=true when an OutWidth and OutHeight are specified together. This is because the script can't know
how wide to make the picture before adding borders, so to prevent ambiguity, it'll output an error message
instead.

To add to the confusion, there's an exception to the previous rule. Borders can be enabled when an OutDAR is
specified, as long as a CropDAR is also specified. In fact, borders are automatically enabled. The reason for the
exception is because when a CropDAR is specified, the script knows how wide the cropped picture will be. It's
cropped according to the CropDAR and the OutDAR can then determine the final display aspect ratio, including
borders. Confused? Info=true will always tell you what the script is doing.

=================================================================================
	     Borders (default, false)
=================================================================================

In full resizing mode, when OutWidth & OutHeight are both greater than zero, they determine the output aspect
ratio and the script crops the picture as required to prevent aspect error (ignoring the OutDAR option for the
moment).
When Borders=true, instead of the picture being cropped to the aspect ratio set by OutWidth & OutHeight,
borders are added instead (although the picture can still be cropped by a small amount to prevent aspect error).

When Borders=true, after any specified cropping, if the remaining picture aspect ratio is less than the output
aspect ratio (OutWidth / OutHeight), the source is resized based on the OutHeight, and borders are added to
the sides to achieve the OutWidth.
Likewise, when the the picture aspect ratio is wider than the output aspect ratio (OutWidth / OutHeight), the
source is resized based on the specified OutWidth and borders are added top and bottom to achieve the specified
OutHeight.

In full resizing mode, Borders=true can have no effect unless both OutWidth and OutHeight are specified (greater
than zero). Exactly the same principle applies when an OutDAR or OutSAR is specified. They simply change the
aspect or "shape" of the pixels. OutWidth & OutHeight still set the output resolution and borders are added
left/right or top/bottom as they would be for a non-anamorphic output.

See the NoResize and ResizeWO section for details on how OutWidth or OutHeight add borders in those modes.

=================================================================================
	     CleanBorders (default, false)
=================================================================================

CleanBorders can be enabled to crop away existing borders and replacing them with new, clean ones.
CleanBorders forces NoResize=true, so it can be used for both anamorphic and non-anamorphic sources. The
output width and height are always the same as the source width and height, even if auto-cropping is enabled.

CleanBorders=true is similar to AviSynth's LetterBox() function, which replaces the picture edges with black
borders (or some other color) without changing the frame size, however CleanBorders adds the borders as
evenly as possible between left/right and top/bottom, to restore the original frame size while keeping the
cropped picture centred in the frame.

The CropDAR option can also be used to crop the picture to a particular aspect ratio before borders are
added for the original frame size.

The Mod option is ignored when CleanBorders=true. Instead, any specified cropping is adjusted according to
the minimum permitted for the color format (mod2 for YV12), then borders are added to the top and bottom
and/or sides to achieve the original source dimensions.

=================================================================================
	     BColor (default, color_black or $000000)
=================================================================================

Border Color.

Specifies the color for the borders when Borders=true or CleanBorders=true. See the "colors_rgb.avsi" script in
the AviSynth plugins folder for a list of colours. The default is black (BColor=$000000 or BColor=color_black).

BColor only applies to the CropResize function adding plain borders to the picture. When Frosty=true, the
included FrostyBorders function adds borders and it has it's own BColor argument. See the separate help file
FrostyBorders help file for usage details.

When NoResize or ResizeWO are true it's possible for CropResize to add borders to all four sides of the video.
If Frosty=true, the FrostyBorders function adds the larger of the borders while CropResize adds the others,
and the BColor argument sets the color of the plain borders being added by CropResize.

=================================================================================
	     Frosty (default, false)
=================================================================================

Frosty=true enables "FrostyBorders" using the included FrostyBorders function rather than plain borders.
"FrostyBorders" change color with the video.
The borders must be at least 16 pixels wide for the Frosty option to work. If the borders are less than 16 pixels
wide, they revert to plain borders.

The Frosty border options are configured with the global FCropResize function.
See the "CropResize Frosty Help" file for info.

The global FCropResize function also has a Frosty argument. For CropResize, Frosty=true enables the adding of
borders with the included FrostyBorders function. For the global FCropResize function, Frosty=false disables the
adding of FrostyBorders and plain black/color borders are added instead, but the included FrostyBorders function
is still used to add the borders.

=================================================================================
	     ColorCorrect (default, 0)
=================================================================================

When not used in combination with the ColorMode argument, ColorCorrect > 0 enables automatic color correction
(conversion) when upscaling or downscaling, and also specifies the plugin to be used for the conversion.
Automatic color correction only applies in full resizing mode and only for YUV video.
When a particular type of color conversion is specified via the ColorMode argument, ColorCorrect only specifies
the conversion method.

ColorCorrect = 
0 - Disabled
1 - Color correction with AVSResize (170m for standard definition, HD and UHD are the same as ColorCorrect=2)
2 - Color correction with AVSResize (470bg for standard definition, HD and UHD are the same as ColorCorrect=1)
3 - Color correction with HDRTools (170m for standard definition, HD and UHD are the same as ColorCorrect=4)
4 - Color correction with HDRTools (470bg for standard definition, HD and UHD are the same as ColorCorrect=3)
5 - Color correction with HDRMatrix (supports all YUV formats and conversions between SD and HD)

The resolution assumptions for automatic color correction are:

SD: (Display Width <= 1056) AND (Height < 600)
HD: ((Display Width > 1056) OR (Height >= 600)) AND ((Display Width <= 1920) AND (Height <= 1080))
UHD: (Display Width > 1920) OR (Height > 1080)

SD is assumed to be Rec.601.
HD is assumed to be Rec.709.
UHD is assumed to be Rec.2020.
If you know these assumptions are incorrect for your source, don't enable the ColorCorrect argument, or use
ColorMode to specify the correct type of conversion.

The following is my (current) understanding of color conversion and explains why the CropResize automatic
color correction option works the way it does.

For standard definition, "170m" refers to 525 line (NTSC) and "470bg" refers to 625 line (PAL).
170m and 470bg have slightly different "color primaries" (red, green and blue). Red and blue are virtually the
same, while green is a little different.
Rec.709 (HD colorimetry) uses exactly the same primaries for red and blue as 470bg, while green is halfway
between the 170m and 470bg green primaries. The difference isn't great enough to matter much, if at all.
170m and 470bg generally use the Rec.601 matrix for converting YUV video to RGB on playback.
HD generally uses the Rec.709 matrix to convert YUV video to RGB.

When downscaling or upscaling between HD and SD, it's arguably good practice to convert between Rec.709 and
Rec.601 accordingly, although it's possible to leave the colorimetry unaltered and specify the original colorimetry
when encoding (x264 or x265 etc). A media player may or may not use the specified colorimetry.
To the best of my knowledge, even in broadcast situations, when converting between HD and SD colorimetry it's
standard practice to convert using a single formula, ignoring the slight difference in color primaries. It's using
the wrong matrix for converting to RGB on playback that makes a noticeable difference to the colors. HDRMatrix
converts between SD and HD colorimetry using the "matrix only" conversion method, but it's quite fast.

UHD colorimetry (Rec.2020) is a whole other thing, because the red, green and blue primaries are vastly different.
The Rec.2020 primaries are outside the sRGB/Rec.709 gamut. To convert between UHD and HD, or UHD and SD,
the color primaries should be converted too. CropResize uses AVSResize or HDRTools to convert to/from UHD
colorimetry. As a result, HD or SD converted to/from Rec.2020 when upscaling will look quite "wrong" when
displayed on a HD monitor and/or with a player that doesn't understand UHD colorimetry.
It's possible to convert to/from Rec.2020 using the "matrix only" method, leaving the primaries as HD or SD, but
AVSResize or HDRTools both convert the color primaries too.

The difference between converting both the color primaries and matrix, and converting using a "matrix only"
method can be very hard to spot for conversion between Rec.601 and Rec.709, and chances are,
HD players/displays mostly use a "matrix only" method for converting rec.601 to Rec.709 on playback anyway,
also ignoring the slight difference in color primaries, in which case a "matrix only" conversion between HD and SD
using HDRMatrix might be a better choice.....

Info=true will tell you if color correction/conversion is taking place (ColorCorrect information is not displayed
otherwise), and it also displays the type of conversion. If the script attempts to convert to/from UHD colorimetry
and ColorCorrect=5 is specified, it'll output an error message.

Automatic color correction when upscaling or downscaling is disabled by default, but it can be enabled by
default also, in which case ColorCorrect=0 would be required to disable it. To have automatic color correction
enabled as the default, open the CropResize script with Notepad and find the 18th line from the bottom.
Change zero to 1, 2, 3, 4 or 5 (according to the conversion method you wish to have enabled as the default) and
resave the script. The line in question looks like this:

function CR_ColorCorrect() { return 0 }

Please remember, "automatic" color correction applies only to YUV video (not RGB).

=================================================================================
	     ColorMode (default, "")
=================================================================================

ColorMode specifies the type of color conversion. ColorMode over-rides any automatic color correction that
would otherwise take place if ColorCorrect > 0. Conversions between SD (rec.601), HD (rec.709) and
UHD (rec.2020) are specified in the following manner.

HD to SD:	ColorMode = "709-601"
UHD to HD:	ColorMode = "2020-709"
UHD to SD:	ColorMode = "2020-601"

SD to HD:	ColorMode = "601-709"
HD to UHD:	ColorMode = "709-2020"
SD to UHD:	ColorMode = "601-2020"

While ColorMode specifies the type of color conversion, over-riding any autimatic color correction, the
ColorCorrect argument is still used to specify the conversion method (AVSResize, HDRTools or HDRMatrix).

Forcing a conversion between HD and SD colorimetry using AVSResize:
CropResize(ColorCorrect=1, ColorMode="709-601") - converting to the 170m SD color primaries
or
CropResize(ColorCorrect=2, ColorMode="709-601") - converting to the 470bg SD color primaries

Forcing a conversion between SD and HD colorimetry using HDRTools:
CropResize(ColorCorrect=3, ColorMode="709-601") - converting to the 170m SD color primaries
or
CropResize(ColorCorrect=4, ColorMode="709-601") - converting to the 470bg SD color primaries

Forcing a conversion between HD and SD with HDRMatrix:
CropResize(ColorCorrect=5, ColorMode="709-601")

It's also possible to specify the SD color primaries directly with 601N or 601P rather than just using 601.
"N" for 525 line or (NTSC) forces a conversion to/from the 170m color primaries.
"P" for 525 line or (PAL) forces a conversion to/from the 470bg color primaries.
(It's not technically correct to refer to the above formats as NTSC or PAL, as they're analogue, but "N" and "P"
are an easy way to distinguish between the two).
When a color conversion is specified with 601N or 601P, the ColorCorrect argument cannot equal 5, but it
can be unspecified, in which case AVSResize is automatically used if it's also being used for resizing, otherwise
it's HDRTools.

The 601N and 601P options also make it possible to convert between the NTSC (170m color primaries) and
PAL (470bg color primaries).

SD 170m to SD 470bg:  ColorMode = "601N-601P"
SD 470bg to SD 170m:  ColorMode = "601P-601N"

HD to SD 170m:   ColorMode = "709-601N"
HD to SD 470bg:  ColorMode = "709-601P"
SD 170m to HD:   ColorMode = "601N-709"
SD 470bg to HD:  ColorMode = "601P-709"

UHD to SD 170m:   ColorMode = "2020-601N"
UHD to SD 470bg:  ColorMode = "2020-601P"
SD 170m to UHD:   ColorMode = "601N-2020"
SD 470bg to UHD:  ColorMode = "601P-2020"

If ColorCorrect=0 when a color conversion is specified with ColorMode, the script converts in the following
manner by default (excluding the use of 601N or 601P).

If AVSResize is specified as the resizing method, it also converts the colors.
(ColorCorrect=2 is set automatically)
Otherwise, for YUV conversions between HD and SD colorimetry, HDRMatrix converts the colors.
(ColorCorrect=5 is set automatically)
For any other conversions, HDRTools is used.
(ColorCorrect=4 is set automatically)

=================================================================================
	     Resizer (default, "Spline36ResizeMT" or "Spline36Resize")
=================================================================================

Specify a resizer other than the default.

If the ResampleMT plugin is loaded, the default resizing method is "Spline36ResizeMT", otherwise it's
"Spline36Resize".

AVSResize can be specified for resizing by preceding the resizer name with "z_".
The following resizing methods are supported.
"z_Point", "z_Bilinear", "z_Bicubic", "z_Spline16", "z_Spline36", "z_Spline64", "z_Lanczos" and "z_Lanczos4"

Resizing can be specified with or without appending "Resize".
Resizer="z_Bicubic"
or
Resizer="z_BicubicResize"

As the default resizing method is Spline36, Resizer="z_" will resize with AVSResize and Spline36.
Resizer="z_Spline36"
and
Resizer="z_Spline36Resize"
are equally valid.

Any resizer can be used if it has appropriately named arguments for cropping (all AviSynth, and most 3rd
party resizers). Appending "resize" to the function name is also unnecessary for AviSynth's native resizers.
Bicubic resizing can be specified as Resizer="Bicubic" or Resizer="BicubicResize".

If the ResampleMT plugin is loaded, it's resizers can be specified by appending MT to the resizer name.
BicubicMT, BicubicResizeMT and even BicubicMTResize would be okay.

If a resizing method other than Spline36 is desired as the default, it can be changed by opening the CropResize
script with Notepad and finding the 10th line from the bottom, it looks like this:

function CR_ResizerDefault() { return "" }

Specify your preferred resizing method and resave the script. For example, to make BicubicResizeMT the default,
the above line would be changed to the following.

function CR_ResizerDefault() { return "BicubicResizeMT" }

CropResize also includes wrapper functions for enabling an alternative resizing method without having to use the
Resizer argument and type a resizer name. The alternative resizer can be enabled simply by appending an "X" to
the CropResize or GCropResize function names. ie

CropResizeX()
GCropResizeX()

Appending "X" would resize with the Resize8 script by default, but it can be any compatible resizer.
To change the alternative resizing method when "X" is appended to a function name, open the CropResize
script with Notepad and find the 6th line from the bottom. Change "Resize8" in that line to your preferred
alternative resizing and resave the script. ie

This line:
function CR_ResizerX() { return "Resize8" }

would be changed to the following to use BicubicResize instead of Resize8.
function CR_ResizerX() { return "BicubicResize" }

=================================================================================
	     RStr (default, "")
=================================================================================

Resizer String

Specify named resizer arguments as a string. For example:
CropResize(1280,720, Resizer="Bicubic", RStr="b=0.5,c=0.5")
CropResize(1280,720, Resizer="Spline36ResizeMT", RStr="prefetch=4, threads=2")

When a resizer argument is a string, the tripple quote method can be used.

CropResize(768,576, Resizer="Resize8", RStr="""Kernel="Bicubic", a1=0.5, a2=0.5""")

Similar to specifying default resizers using the functions at the end of the CropResize script described above,
there's two functions that can be used to specify default resizing strings for the default resizers. They are:

function CR_RStrDefault() { return "" }
function CR_RStrX() { return "" }

=================================================================================
	     GMode (default, 1)
=================================================================================

Global Mode. Possible values are 1 & 2 for GCropResize, and 0, 1 & 2 for CropResize.

Detailed information for GMode can be found following the "Global Options" section, as GMode mainly serves a
purpose when the global GCropResize function is used, so understanding the GMode option requires understanding
how the global GCropResize function works.

=================================================================================
	     RMode (default, false)
=================================================================================

Resize mode enables the "common resizing" functionality.
When multiple instances of CropResize are used in a script, sometimes it's advantageous for each instance to
always output the same resolution. For the example below, if a cropping preview was enabled for one instance,
it's output would change to the resolution of the source video while displaying the preview. This would cause
AviSynth to output an error message, as each Trim instance would no longer have the same resolution
(unless the source was actually 832x468).
The RMode option causes each CropResize instance to be resized to the same resolution as the CropResize
instance where RMode=true, preventing this error. It doesn't matter if the CropResize instance where RMode=2
is displaying a cropping preview or outputting the cropped and resized video, or even if the specified OutWidth
or OutHeight is changed temporarily, the following CropResize instances will still be resized to match.

ClipA = NTSC DVD as the source
ClipB = 1280x720 source.

ClipA.Trim(0,1999).CropResize(832,468, 12,4,-8,-4, RMode=true)\
++ClipA.Trim(2000,2999).CropResize(832,468, 8,0,-8,-2)\
++ClipB.Trim(0,1999).CropResize(832,468, 6,4,-12,-2)\
++ClipA.Trim(3000,3999).CropResize(832,468, 8,0,-8,-2, CPreview=1)\
++ClipA.Trim(4000,4999).CropResize(832,468, 8,0,-8,-2)\
++ClipB.Trim(2000,3999).CropResize(832,468, 6,4,-12,-2, CPreview=1)

For the above example, enabling a cropping preview for any CropResize instance with "ClipA" as the source would
normally cause it's resolution to change to 720x480 while displaying the preview. For any CropResize instance
with "ClipB" as the source, the resolution would normally change to 1280x720. As the first CropResize instance has
RMode=true though, each following instance would be automatically resized to 832x468, to match the resolution
of the first CropResize.
If a cropping preview was enabled for the first CropResize instance, it's output would temporarily change to
720x480 while displaying the preview. Therefore each following CropResize instance would also be temporarily
resized to 720x480.

Text is displayed over the video to indicate when an instance of CropResize is being temporarily resized due to
RMode=true.

RMode can be true for more than one instance of CropResize in a script, and each instance will create global
resizing variables for any CropResize instances that follow, but as a rule it'd only make sense to set RMode=true
for the first instance of CropResize in a script.

RMode cannot be used as an argument for the global GCropResize function (see the "Global Options" section), only
the CropResize function itself. Specifying RMode=true for the GCropResize function will result in an error message.

=================================================================================
	     PicDim (default, 0)
=================================================================================

Picture Dimming when Info=true, to make the text easier to read. The range is 0 (no dimming) to 255 (maximum
dimming).

The script can automatically dim the picture a little when Info=true, unless a cropping preview is enabled at the
same time as Info=true, or when color conversion is being applied. It's possible to change the default dimming
amount, and also change whether dimming is disabled by a cropping preview or when color correction is being
applied.

Open the script with Notepad and find the 16th line from the bottom. It looks like the line below. To change
the amount by which the picture is automatically dimmed, edit that line. It looks like the line below.
Change the default value of 0 to any integer from 0 to 255, then resave the script.

function CR_InfoAutoPicDim() { return 0 }

To enable automatic dimming for Info=true even when a cropping preview is enabled at the same time, or when
color conversion is being applied, find the 15th line from the bottom of the script, change false to true and resave
the script.

function CR_InfoAutoPicDimWhenCPreviewOrColorCorrect() { return false }

=================================================================================
	     Position (default, false)
=================================================================================

When Position=true, the current frame number and position in time are displayed over the video. Position=true
works no matter what mode the script is in, even when Info=true or a cropping preview is enabled. The location
over the video changes according to the mode, but it's always displayed.

=================================================================================
	     Info (default, false)
=================================================================================

When Info=true, information is overlaid on the video regarding the cropping being applied, the input/output
resolutions and aspect ratios, and the resizing method. Info=true will provide the correct sample aspect ratio for
encoding when an output display aspect ratio has been specified. If you're not sure what the script is doing or
why, Info=true will tell you.

Info=true can still be used when one of the script cropping previews is enabled, replacing the more limited
information provided by the cropping preview. The cropping preview itself is still displayed.

The AviSynth version displayed when Info=true (for AviSynth 2.6 and AviSynth+) is formatted to display neatly
by default. To disable the formatting of the AviSynth version info, open the script with Notepad and find the 14th
line from the bottom. It looks like the line below. Change true to false and resave the script.

function CR_InfoDisplayFormattedAvisynthVersion() { return true }

=================================================================================
=================================================================================
	     MeGUI Support
=================================================================================
=================================================================================

MeGUI support is independent of the script's ability to use a specified Input or Output aspect ratio.
MeGUI support is enabled by default, and there's generally no need to disable it, but it's possible. There's
instructions at the end of this section.

Please note: Any global MeGUI DAR in a script is ignored by all but the first instance of CropResize by default.
CropResize will not use an MeGUI global display aspect ratio if an instance of CropResize is added to a script
prior to any MeGUI display aspect ratio. There's very little need to work around this limitation, but it can be done
by adding the following to a script after any MeGUI display aspect ratio:

global gPriorScript=false

How MeGUI support works:
If MeGUI's anamorphic encoding is enabled, MeGUI adds a display aspect ratio to the script. ie

global MeGUI_darx = 16
global MeGUI_dary = 9

When the script is loaded for encoding, MeGUI calculates the correct sample (pixel) aspect ratio based on the
output resolution and the DAR added to the script, so the MeGUI DAR is normally the script's Output DAR,
however when CropResize follows MeGUI's DAR in a script, it becomes the Input DAR for CropResize to use as
the basis for it's cropping and resizing calculations. CropResize then updates the original MeGUI DAR global
variables with new values according to it's output, and the new DAR variables become the script's Output DAR.

The new DAR variables are not physically added to the script, but MeGUI will still use them to calculate the
correct sample aspect ratio when it loads the script for encoding. This can be confirmed by opening the script
with MeGUI's preview and checking the DAR displayed at the bottom of the preview window.
The MeGUI DAR variables created by CropResize are shown when Info=true, or when a script cropping preview is
enabled, they're shown as the display aspect ratio (if the output is anamorphic). ie "DAR 16:9".

For a 4:3 (non-ITU) NTSC DVD, MeGUI would add the following to a script (anamorphic encoding enabled).

global MeGUI_darx = 4
global MeGUI_dary = 3

If MeGUI cropped 10 pixels each side from the above 4:3 NTSC DVD, and 4 from both the top and bottom, the
aspect ratio information would be updated to the following (any difference dependent on the acceptable aspect
error setting in MeGUI's AviSynth Profile).

global MeGUI_darx = 700
global MeGUI_dary = 531
Crop(10,4,-10,-4)

Therefore MeGUI's script creator could be used to apply and preview cropping, and CropResize could be used
to resize from there, basing it's calculation on the updated MeGUI DAR variables.

CropResize always creates MeGUI's global aspect variables by default. It's not necessary to first create the script
with MeGUI or use MeGUI's DAR as an input DAR for CropResize. Each CropResize instance in a script updates
any existing DAR variables to match it's output. When CropResize resizes to square pixel dimensions, the global
MeGUI variables are created as, or updated to, "undefined".

When it's preferable for each instance of CropResize to use the same input display aspect ratio, the MeGUI DAR
can be made global by preceding CropResize with the GCropResize function. The GCropResize function doesn't
need to be used to specify any options, it just needs to precede CropResize.

For the example below, each instance of CropResize would use 15:11 as the input display aspect ratio, and 4:3 as
the output display aspect ratio.

global MeGUI_darx = 15
global MeGUI_dary = 11

GCropResize(OutDAR=4.0/3.0)

Trim(0, 1999).CropResize(720,480, 8,2,-8,-4)\
++Trim(2000, 2999).CropResize(720,480, 18,2,-16,-4)\
++Trim(3000, 3999).CropResize(720,480, 8,2,-8,-4)\
++Trim(4000, 4999).CropResize(720,480, 12,2,-16,-2)

Disabling MeGUI Support:

Should you wish to disable MeGUI support completely, open the CropResize script with Notepad and find the 13th
line from the bottom. It looks like the line below. Change true to false, then resave the script.

function CR_MeGUI_DAR() { return true }

=================================================================================
=================================================================================
	     Global Options
=================================================================================
=================================================================================

GCropResize() is a special wrapper function for enabling CropResize arguments globally. GCropResize() only
outputs the source video, except when global auto-cropping is enabled, in which case it outputs the
auto-cropped clip.
GCropResize() is designed to save some typing when there's more than one instance of CropResize in a script,
however each following instance of CropResize can over-ride the global options.

Setting global values for arguments has the potential to cause problems when more than one source video is
used in a script. This is explained in the "GMode" section.

When the global GCropResize function is used, specifying zero for Outwidth and OutHeight causes each
CropResize instance to use any global values set by GCropResize. This makes specifying different cropping
a little easier. ie

GCropResize(1280,720, 0,8,-4,-8)
CropResize(0,0, -16,0,0,-4) The output dimensions will still be 1280x720

A few rules to note when using the global GCropResize function:
- Auto-cropping can't be enabled (or disabled) for an individual instance of CropResize if it's previously been
enabled globally by the GCropResize function.
- It's possible to over-ride the OutDAR (or a global OutSAR) for each instance or CropResize, but it almost never
makes sense to do so as there can be only a single OutDAR/OutSAR per script. To correct an aspect ratio
problem, over-ride the global InDAR/InSAR instead.

To illustrate how the global GCropResize function works, for the example below, each instance of CropResize would
see the input display aspect ratio as 16:9, except for the second instance. The first three CropResize instances
would apply cropping of Crop(8,2,-8,-4), while the last three would apply the cropping specified for each.

GCropResize(720,576, 8,2,-8,-4, InDAR=16.0/9.0, OutDAR=20.0/11.0, AutoCrop=true)
Trim(0,1999).CropResize()\
++Trim(2000,2999).CropResize(InDAR=20.0/11.0)\
++Trim(3000,3999).CropResize()\
++Trim(4000,4999).CropResize(0,0, 12,8,-16,-6)\
++Trim(5000,5999).CropResize(0,0, 12,4,-8,-4)\
++Trim(6000,6999).CropResize(0,0, 12,8,-16,-6)


Each argument for specifying an aspect ratio (CropDAR, InDAR, InSAR, OutDAR & OutSAR) can be reset by
CropResize by setting it's value to zero, over-riding any global aspect ratio. For the example below, the first
CropResize instance would use an InDAR of 16:9, while for the second instance, no InDAR is specified (the
source would be considered non-anamorphic).

GCropResize(720,576, InDAR=16.0/9.0, OutDAR=20.0/11.0)

Clip1.Trim(0,1999).CropResize(0,0, 8,2,-8,-4)++\
Clip2.Trim(0,1999).CropResize(0,0, 6,2,-2,-2, InDAR=0)


Global auto-cropping:
When GCropResize() enables auto-cropping, ie GCropResize(AutoC=true), it outputs an auto-cropped clip for each
following instance of CropResize to use as the source video. This allows the AutoCrop plugin to check the entire
video, and each instance of CropResize will have the same auto-cropping applied. GCropResize creates global
variables for the original source width and height when global auto-cropping is enabled, and by default the
following instances of CropResize base their cropping and resizing calculations on those global width and height
variables, rather than the width and height of the auto-cropped clip.
This allows the original source InDAR to be specified after global auto-cropping, rather than the user having to
calculate a new InDAR for the auto-cropped clip.

When more the one instance of GCropResize is used in a script, the second instance doesn't automatically reset
any global variables, although it's possible to specify new values for each. By default, a second GCropResize
instance uses the same values for global variables as the first.

=================================================================================
	     GMode (default, 1)
=================================================================================

Global Mode. Possible values are 0, 1 & 2 for CropResize, and 1 & 2 for GCropResize.

GMode is never set as a global variable even when used with the GCropResize function. It's used to instruct
individual instances of CropResize and GCropResize how to behave, so each instance must have GMode configured
accordingly. Both CropResize and GCropResize default to GMode=1.

The following "rules" for using GCropResize and the GMode option only need to be strictly adhered to when global
auto-cropping is enabled by an instance of GCropResize, and even then, only when an InDAR/InSAR is specified by
an instance of GCropResize. This is because when global auto-cropping is enabled, GCropResize creates global
variables for the source width and height, allowing CropResize to "see" the original source resolution and crop and
resize correctly based on the source display aspect ratio. For non-anamorphic sources the following "rules" only
matter for Info=true to display all the information correctly, but adhering to the following "rules" is recommended.

GCropResize can create two distinct sets of global variables. When GMode=2 for a GCropResize instance other
than the first, a second set of global variables is created. This is mainly intended to allow global variables to be
used for two source videos in a script, but it's possible to use two sets of global variables with a single source.

Specifying GMode=1 or GMode=2 for an individual instance of CropResize tells it which set of global variables to
use, and more importantly, to see the correct source resolution when global auto-cropping is enabled.

GMode=0 prevents CropResize from using any global MeGUI display aspect ratio variables for the input display
aspect ratio, however GMode=0 does allow CropResize to use some of the global variables created by GCropResize
(GMode=1) by default. See the table at the end of this section.


When working with a single source video and two sets of global variables, global auto-cropping must only be
enabled by the second GCropResize instance to work correctly, or to put it another way, by the GCropResize
instance where GMode=2. If global auto-cropping is enabled by the first instance of GCropResize, it'd output the
auto-cropped clip and the second GCropResize instance wouldn't see the original video resolution. The script
can't enforce the correct usage in this scenario.

SomeVideoSource("D:\Some Video.mkv")

GCropResize(720,480, Info=true, InDAR=20.0/11.0, OutDAR=16.0/9.0, CPreview=1)
GCropResize(720,480, 14,0,-16,-2, InDAR=16.0/9.0, AutoC=true, GMode=2) # global auto-cropping is okay here.

Trim(0,1999).CropResize()\
++Trim(2000,2999).CropResize()\
++Trim(3000,3999).CropResize(0,0, 6,4,-12,-2)\
++Trim(1000,1999).CropResize(GMode=2)\
++Trim(2000,2999).CropResize(GMode=2)\
++Trim(6000,6999).CropResize()\
++Trim(4000,4999).CropResize(GMode=2)\
++Trim(5000,5999).CropResize(GMode=2)


The following is an example of how to use the GMode option with two source videos while appending sections
of them with Trim(). Global auto-cropping can be enabled for either. Each GCropResize instance must "see" the
correct source video in order to pass along the correct source dimensions. For this example we'll assume Clip1
is a PAL DVD with a 720x576 resolution, and Clip2 is an NTSC DVD with a 720x480 resolution. The final output
is 720x480 with a 16:9 display aspect ratio.


Clip1 = SomeVideoSource("D:\DVD 1\Some PAL DVD.vob")
Clip2 = SomeVideoSource("D:\DVD 2\Some NTSC DVD.vob")
ClipA = Clip1.GCropResize(720,480, InDAR=20.0/11.0, OutDAR=16.0/9.0, CPreview=1, Info=true, AutoC=true)
ClipB = Clip2.GCropResize(0,0, 14,0,-16,-2, InDAR=16.0/9.0, GMode=2)

NewClip = \
ClipA.Trim(0,1999).CropResize()\
++ClipA.Trim(2000,2999).CropResize()\
++ClipA.Trim(3000,3999).CropResize(0,0, 6,4,-12,-2)\
++ClipA.Trim(4000,4999).CropResize()\
++ClipA.Trim(5000,5999).CropResize()\
++ClipB.Trim(1000,1999).CropResize(0,0, 2,0,0,-4, GMode=2)\
++ClipB.Trim(2000,2999).CropResize(GMode=2)\
++ClipA.Trim(6000,6999).CropResize()\
++ClipB.Trim(4000,4999).CropResize(GMode=2)

return NewClip


To explain what's happening above:
The GCopResize instance following "Clip1" sees Clip1 as the input video and applies global auto-cropping,
outputting an auto-cropped version of Clip1, as well as creating a set of global variables. "ClipA" therefore
becomes the auto-cropped version of Clip1.
The GCopResize instance following "Clip2" sees Clip2 as the input video, creates a second set of global variables
due to GMode=2, and passes Clip2 through untouched, so "ClipB" remains the same as Clip2.
Finally, each CropResize instance needs to be instructed as to which set of global variables to use, and naturally
each instance of CropResize with "ClipB" as the source video would have GMode=2 specified. GMode=1 doesn't
have to be specified for the CropResize instances with "ClipA" as the source, as GMode=1 is the default.


The following example introduces a third source video. Only two sets of global variables can be created by
GCropResize, however specifying GMode=0 for an individual instance of CropResize causes it to ignore any global
variables created for the source width and height, so the width and height of the input video are used for
cropping and resizing calculations.
The fifth instance of CropResize below has a 720p video as it's source. Without Gmode=0, the source resolution
would be assumed to be 720x576.


Clip1 = SomeVideoSource("D:\DVD 1\Some PAL DVD.vob")
Clip2 = SomeVideoSource("D:\DVD 2\Some NTSC DVD.vob")
ClipA = Clip1.GCropResize(720,480, InDAR=20.0/11.0, OutDAR=16.0/9.0, CPreview=1, Info=true, AutoC=true)
ClipB = Clip2.GCropResize(0,0, 14,0,-16,-2, InDAR=16.0/9.0, GMode=2)
ClipC = SomeVideoSource("D:\Some 720p Video.mkv")

NewClip = \
ClipA.Trim(0,1999).CropResize()\
++ClipA.Trim(2000,2999).CropResize()\
++ClipA.Trim(3000,3999).CropResize(0,0, 6,4,-12,-2)\
++ClipA.Trim(4000,4999).CropResize()\
++ClipC.Trim(5000,5999).CropResize(GMode=0)\
++ClipB.Trim(1000,1999).CropResize(0,0, 2,0,0,-4, GMode=2)\
++ClipB.Trim(2000,2999).CropResize(GMode=2)\
++ClipA.Trim(6000,6999).CropResize()\
++ClipB.Trim(4000,4999).CropResize(GMode=2)

return NewClip

=================================================================================
=================================================================================

When using the GCropResize function and, especially with two sets of global variables, there's one golden
rule to always follow: Make Info=true your best friend.

The list below shows which global variables created by GCropResize(GMode=1) are passed along to a second
instance of GCropResize when GMode=1 or GMode=2, or to CropResize when GMode=0 (unless a different
value is specified).

=================================================================================
=================================================================================

OutWidth, OutHeight       Passed between all instances of (G)CropResize regardless of GMode

CL, CT, CR, CB            Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

CropDAR, CSplit, CAlign   Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

AutoC                     Not Applicable
CThresh                   Not Applicable
CStart                    Not Applicable
CSample                   Not Applicable

CPreview                  Passed between all instances of GCropResize regardless of GMode
                          Ignored by CropResize when GMode=0

CLine                     Passed between all instances of (G)CropResize regardless of GMode

InDAR, InSAR              Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

OutDAR, OutSAR            Passed between all instances of (G)CropResize regardless of GMode
AutoAspect                Passed between all instances of (G)CropResize regardless of GMode
Mod, HMod                 Passed between all instances of (G)CropResize regardless of GMode

NoResize, ResizeWO        Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

Borders, CleanBorders     Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

BColor, Frosty            Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

ColorCorrect, ColorMode   Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

Resizer, RStr             Passed between all instances of (G)CropResize regardless of GMode

GMode                     Not Applicable
RMode                     Not Applicable

PicDim                    Passed between all instances of (G)CropResize regardless of GMode

Position                  Passed between instances of GCropResize where GMode=1
                          Passed between instances of GCropResize where GMode=2
                          Ignored by CropResize when GMode=0

Info                      Passed between all instances of (G)CropResize regardless of GMode

=================================================================================
=================================================================================
	     Wrapper Functions
=================================================================================
=================================================================================

---------------------------------------------------------------------------------
The wrapper functions below require the "CropResize Wrapper Functions" script.
---------------------------------------------------------------------------------

The wrapper functions provide an easy way to enable the default alternative resizer globally, to set Info=true
globally, and to enable and disable the default cropping preview globally.

CropResizeX()  - is the same as CropResize(), but it enables the default alternative resizing method.
See the information at the top of the "CropResize Resizer Functions" script for details.

To enable the default cropping preview, each function can be appended with a "p" (lower case is used in
the examples, but AviSynth isn't case sensitive).

pCropResize()
pCropResizeX()

To set Info=true, each function can be appended with an "i".

iCropResize()
iCropResizeX()

To enable the default cropping preview and set Info=true at the same time, the order they need to be
appended is "pi".

piCropResize()
piCropResizeX()

As the above wrapper functions enable the CPreview, Resizer and Info arguments globally, they're handy
when used in the following manner, where there's multiple instances of CropResize in a script.

Trim(0, 99).piCropResizeX(1280,720)\  -  enables the default CPreview, Resizer, and Info=true (all globally)
++Trim(1000,1999).CropResize(1280,720)\
++Trim(2000,2999).CropResize(1280,720)\
++Trim(3000,3999).CropResize(1280,720)\
++Trim(4000,0).CropResize(1280,720)

For convenience, there are also equivalent wrapper functions for the global GCropResize function.

GCropResize()
GCropResizeX()
pGCropResize()
pGCropResizeX()
iGCropResize()
iGCropResizeX()
piGCropResize()
piGCropResizeX()

In addition to the above, wrapper functions allowing abbreviated versions of the function names are also included.
CR() can be used instead of CropResize()
GCR() can be used instead of GCropResize()
Appending letters to the abbreviated function names works the same way.

CR()
CRX()
pCR()
pCRX()
iCR()
iCRX()
piCR()
piCRX()

GCR()
GCRX()
pGCR()
pGCRX()
iGCR()
iGCRX()
piGCR()
piGCRX()

=================================================================================
=================================================================================
	     Thanks to len0x
=================================================================================
=================================================================================

CropResize was inspired by AutoGK, a popular encoding GUI back when Xvid and AVI ruled the world.
CropResize was initially created to duplicate AutoGK's cropping and resizing abilities, with the same goal of
cropping and resizing without having to calculate or worry about aspect error. Even though it's grown
significantly in functionality, the initial version was based on AutoGK's scripts, so thanks to len0x, the author
of AutoGK, for the inspiration.

=================================================================================
=================================================================================
=================================================================================